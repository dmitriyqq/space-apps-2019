{"version":3,"sources":["logo.svg","static/Gorod.svg","pages/Map.tsx","interfaces/IDataService.ts","services/DataService.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","LeafletMap","Leaflet","Icon","shadowUrl","undefined","className","iconUrl","logo","state","lat","lng","zoom","cities","shouldComponentUpdate","nextProps","_","props","lvl","updateCities","map","handleClick","e","n","min","console","log","latlng","city","dx","dy","v","onClick","handleViewportChange","viewport","setState","Math","max","a","leafletElement","bounds","getBounds","dataService","getCitiesLevel","_southWest","_northEast","error","this","position","Map","ref","center","onViewportChange","TileLayer","attribution","url","filter","population","i","Marker","icon","Default","destroyed","key","Component","YearsResponse","years","CitiesResponse","DataService","base","fetch","resp","json","level","swlat","swlng","nelat","nelng","method","headers","body","JSON","stringify","App","myfunc","Number","$","innerText","ionRangeSlider","skin","from","step","grid","grid_num","grid_snap","s","id","style","height","elevation","name","src","Gorod","type","React","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","imagePath","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1060a732.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.25bf045c.svg\";","module.exports = __webpack_public_path__ + \"static/media/Gorod.bcf9720b.svg\";","import React, { Component } from 'react'\r\nimport { Map, TileLayer, Marker, Popup } from 'react-leaflet'\r\nimport Leaflet from 'leaflet';\r\nimport { IDataService, City, CitiesResponse } from '../interfaces/IDataService';\r\nimport logo from '../logo.svg';\r\n\r\nconst goodicon = new Leaflet.Icon({shadowUrl: undefined, className: 'goodicon'});\r\nconst badicon = new Leaflet.Icon({shadowUrl: undefined, className: 'badicon'});\r\n\r\nconst icon = new Leaflet.Icon({shadowUrl: undefined, iconUrl: logo});\r\n\r\ntype State = {\r\n  lat: number,\r\n  lng: number,\r\n  zoom: number,\r\n  cities: City[],\r\n}\r\n\r\ninterface IProps {\r\n  dataService: IDataService;\r\n  onClick: (city: City) => void;\r\n  lvl: number;\r\n}\r\n\r\nexport class LeafletMap extends Component<IProps, State> {\r\n  state: State = {\r\n    lat: 51.505,\r\n    lng: -0.09,\r\n    zoom: 4,\r\n    cities: []\r\n  }\r\n\r\n  async componentDidMount() {\r\n    this.updateCities();\r\n  }\r\n\r\n  shouldComponentUpdate = (nextProps: any, _: any) => {\r\n    if (this.props.lvl != nextProps.lvl) {\r\n      this.updateCities();\r\n      return true;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  map: any;\r\n\r\n  render() {\r\n    const minZoom = 10;\r\n    const zoom = Math.max(minZoom, this.state.zoom);\r\n    const position: [number, number] = [this.state.lat, this.state.lng]\r\n    return (\r\n      <Map onClick={this.handleClick} ref={(ref) => { this.map = ref; }} center={position} zoom={7} onViewportChange={this.handleViewportChange}>\r\n        <TileLayer\r\n          attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors'\r\n          url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n        />\r\n        {\r\n          this.state.cities.filter(city => city.population > 1000).map((city, i) => \r\n          <Marker icon={new Leaflet.Icon.Default({shadowUrl: undefined, className: city.destroyed ? 'bad' : 'good', iconUrl: undefined})} key={i} position={[city.lat, city.lng]}></Marker>)\r\n        }\r\n      </Map>\r\n    )\r\n  }\r\n\r\n  private handleClick = (e: any) => {\r\n    let n = null;\r\n    let min = 0.1;\r\n    console.log(e);\r\n    const latlng = e.latlng;\r\n    const lat = latlng.lat;\r\n    const lng = latlng.lng;\r\n\r\n    for (const city of this.state.cities) {\r\n      const dx = city.lat - lat;\r\n      const dy = city.lng - lng;\r\n\r\n      const v = dx * dx + dy*dy;\r\n      if (v < min) {\r\n        n = city;\r\n        min = v;\r\n      }\r\n\r\n    }\r\n\r\n    console.log(min);\r\n    if (n != null) {\r\n      this.props.onClick(n);\r\n    }\r\n  }\r\n\r\n  private handleViewportChange = (viewport: any) => {\r\n    this.setState({zoom: Math.max(10, viewport.zoom)})\r\n    this.updateCities();\r\n  }\r\n\r\n  private updateCities = async () => {\r\n    if (this.map && this.map.leafletElement) {\r\n      try {\r\n      const bounds = this.map.leafletElement.getBounds();\r\n\r\n      \r\n      const { cities } = await this.props.dataService.getCitiesLevel(\r\n        this.props.lvl, bounds._southWest.lat, bounds._southWest.lng , bounds._northEast.lat, bounds._northEast.lng);\r\n      \r\n      this.setState(() => ({ cities }))\r\n      } catch(error) {\r\n        console.error(error);\r\n      }\r\n      \r\n    }\r\n  }\r\n}\r\n","export class Year {\r\n    level: number = 0;\r\n    year: number = 1880;\r\n}\r\n\r\nexport class YearsResponse {\r\n    years: Year[] = [];\r\n}\r\n\r\nexport class City {\r\n    id: number = 0;\r\n    name: string = '';\r\n    country: string = '';\r\n    elevation: number = 0;\r\n    population: number = 0;\r\n    iso3: number = 0;\r\n    lng: number = 0;\r\n    lat: number = 0;\r\n    destroyed: boolean = false;\r\n}\r\n\r\nexport class CitiesResponse{\r\n    cities: City[] = [];\r\n}\r\n\r\nexport interface IDataService {\r\n    getYears(): Promise<YearsResponse>;\r\n    getCitiesLevel(level: number, swlat: number, swlng: number, nelat: number, nelng: number): Promise<CitiesResponse> \r\n}","import {YearsResponse, IDataService, CitiesResponse} from '../interfaces/IDataService'\r\n\r\nexport class DataService implements IDataService{\r\n    base: string = 'https://shulaikin.tech:5000'\r\n\r\n    public async getYears(): Promise<YearsResponse> {\r\n        try {\r\n            var resp = await fetch(`${this.base}/years`);\r\n            var json = await resp.json();\r\n            return json as YearsResponse;\r\n        } catch (error){\r\n            console.error(error);\r\n            return new YearsResponse();\r\n        }\r\n    }\r\n\r\n    public async getCitiesLevel(level: number, swlat: number, swlng: number, nelat: number, nelng: number): Promise<CitiesResponse> {\r\n        try {\r\n            var resp = await fetch(`${this.base}/cities_below_level`, {method: 'POST', headers: {\r\n                'Content-Type': 'application/json'\r\n                // 'Content-Type': 'application/x-www-form-urlencoded',\r\n              },body : JSON.stringify({\r\n                level, swlat, swlng, nelat, nelng\r\n            })});\r\n            var json = await resp.json();\r\n            return json as CitiesResponse;\r\n        } catch (error){\r\n            console.error(error);\r\n            return new CitiesResponse();\r\n        }\r\n    }\r\n}","import React from 'react';\r\nimport './App.css';\r\nimport { LeafletMap } from './pages/Map'\r\nimport { DataService } from './services/DataService';\r\nimport Gorod from \"./static/Gorod.svg\"\r\nimport { City } from './interfaces/IDataService';\r\n\r\ninterface IState {\r\n  lvl: number;\r\n  city: City | null;\r\n}\r\nclass App extends React.Component<{}, IState> {\r\n  constructor(props: any) {\r\n    super(props)\r\n    this.state = ({\r\n      lvl: 0,\r\n      city: null,\r\n    })\r\n  }\r\n\r\n  private handleClick = (city: City) => {\r\n    this.setState(() => ({city}))\r\n  }\r\n\r\n  componentDidMount() {\r\n    // const dataservice = new DataService();\r\n    ($(\".js-range-slider-2\") as any).ionRangeSlider({\r\n      skin: \"big\",\r\n      min: 0,\r\n      max: 100,\r\n      from: 0,\r\n      step: 1,            // default 1 (set step)\r\n      grid: true,         // default false (enable grid)\r\n      grid_num: 10,        // default 4 (set number of grid cells)\r\n      grid_snap: false    // default false (snap grid to step)\r\n    })\r\n  }\r\n\r\n  componentDidUpdate() {\r\n\r\n    ($(\".js-range-slider-2\") as any).ionRangeSlider({\r\n      skin: \"big\",\r\n      min: 0,\r\n      max: 100,\r\n      from: 0,\r\n      step: 1,            // default 1 (set step)\r\n      grid: true,         // default false (enable grid)\r\n      grid_num: 10,        // default 4 (set number of grid cells)\r\n      grid_snap: false    // default false (snap grid to step)\r\n    })\r\n  }\r\n\r\n  render() {\r\n\r\n    let s = null;\r\n    if (this.state.city != null) { \r\n      s = <div className=\"smallStakan\">\r\n        <label className=\"lab\">\r\n          <div className=\"fil\" id=\"fill\" style={{ height: `${Math.min(100 - (Math.max(this.state.city.elevation, 0) - this.state.lvl) / Math.max(this.state.city.elevation, 1) * 100, 100)}%` }}>\r\n            \r\n            \r\n          </div>\r\n        </label>\r\n        <h1>{this.state.city.name}</h1>\r\n        <h2>{this.state.city.population} чел.</h2>\r\n        <h2>{this.state.city.elevation} м</h2>\r\n        <img src={Gorod} className=\"gorod\"></img>\r\n      </div>\r\n    }\r\n    \r\n    return (\r\n      <div className=\"cont\">\r\n        <div className=\"stakan\">\r\n          {s}\r\n        </div>\r\n        <div className=\"map\">\r\n          <LeafletMap onClick={this.handleClick} dataService={new DataService()} lvl={this.state.lvl} />\r\n        </div>\r\n        <div className=\"polzynok\" onClick={this.myfunc}>\r\n          <input type=\"number\" className=\"js-range-slider-2\" name=\"my_range\"/>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n  myfunc = () => {\r\n    const a = Number($(\".irs-single\")[0].innerText)\r\n    this.setState({\r\n      lvl: a\r\n    })\r\n  }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport Leaflet from 'leaflet'\r\nReactDOM.render(<App />, document.getElementById('root'));\r\nLeaflet.Icon.Default.imagePath =\r\n  '//cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.4/images/'\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}